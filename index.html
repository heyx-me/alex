<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Chat | heyx-me</title>
    <meta name="theme-color" content="#030305">
    <style>
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #030305;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
        }
        
        /* Chat UI */
        #chat-interface {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            pointer-events: none; /* Let clicks pass through to 3D bg where empty */
        }

        .chat-window {
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            height: 100%;
            max-height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
            background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.4) 20%, rgba(0,0,0,0.8) 100%);
        }

        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            scroll-behavior: smooth;
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 5%);
            mask-image: linear-gradient(to bottom, transparent, black 5%);
        }

        .message {
            max-width: 80%;
            padding: 10px 14px;
            border-radius: 18px;
            font-size: 15px;
            line-height: 1.4;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease-out;
            word-wrap: break-word;
        }

        .message.user {
            align-self: flex-end;
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #e0ffff;
            border-bottom-right-radius: 4px;
        }

        .message.bot {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #f0f0f0;
            border-bottom-left-radius: 4px;
        }

        .input-area {
            padding: 20px;
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        input[type="text"] {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 24px;
            padding: 12px 20px;
            color: white;
            font-size: 16px;
            outline: none;
            transition: all 0.2s;
        }

        input[type="text"]:focus {
            background: rgba(255,255,255,0.15);
            border-color: rgba(0, 255, 255, 0.5);
        }

        button#send-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.4);
            color: #00ffff;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        button#send-btn:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        button#send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button#send-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            margin-left: 2px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Scrollbar */
        #messages::-webkit-scrollbar {
            width: 6px;
        }
        #messages::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    
    <div id="chat-interface">
        <div class="chat-window">
            <div id="messages">
                <!-- Messages will appear here -->
            </div>
            <form id="chat-form" class="input-area">
                <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off">
                <button type="submit" id="send-btn">
                    <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                </button>
            </form>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@supabase/supabase-js": "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { createClient } from '@supabase/supabase-js';

        // --- 3D BACKGROUND ---
        const container = document.getElementById('three-container');
        if (container) {
            initThreeJS(container);
        }

        function initThreeJS(container) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.1
            );
            
            const composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());

            function createTrail(color, xOffset, thickness = 0.015) {
                const points = [];
                for (let i = 0; i < 20; i++) {
                    points.push(new THREE.Vector3(
                        Math.sin(i * 0.4 + xOffset) * 1.5,
                        i * 0.8 - 8,
                        Math.cos(i * 0.4 + xOffset) * 1.5
                    ));
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeom = new THREE.TubeGeometry(curve, 100, thickness, 8, false);
                const tubeMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
                const tube = new THREE.Mesh(tubeGeom, tubeMat);
                scene.add(tube);
                return tube;
            }

            const trail1 = createTrail(0x00ffff, 0);
            const trail2 = createTrail(0xff00ff, Math.PI);
            const trail3 = createTrail(0x00ffff, Math.PI * 0.5, 0.005);
            const trail4 = createTrail(0xff00ff, Math.PI * 1.5, 0.005);

            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<3000; i++) {
                starPos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 });
            scene.add(new THREE.Points(starGeo, starMat));

            function animate() {
                requestAnimationFrame(animate);
                trail1.rotation.y += 0.001;
                trail2.rotation.y -= 0.001;
                trail3.rotation.y += 0.0015;
                trail4.rotation.y -= 0.0015;
                composer.render();
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        // --- CHAT LOGIC (Restored & Adapted) ---
        
        const SUPABASE_URL = 'https://gsyozgedljmcpsysstpz.supabase.co';
        // Key retrieved from previous commit 8b720b0f
        const SUPABASE_ANON_KEY = 'sb_publishable_FJI1hrANejiwsKll-G4zMQ_wRR-Surp';
        const ROOM_ID = 'alex';

        async function initChat() {
            const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            const messagesDiv = document.getElementById('messages');
            const form = document.getElementById('chat-form');
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            
            let userId = null;

            // 1. Authenticate (Anonymous)
            try {
                const { data: { session } } = await supabase.auth.getSession();
                
                if (session) {
                    console.log('Restored session');
                    userId = session.user.id;
                } else {
                    console.log('Signing in anonymously...');
                    const { data, error } = await supabase.auth.signInAnonymously();
                    if (error) throw error;
                    userId = data.user.id;
                }
                console.log('Authenticated as:', userId);
            } catch (err) {
                console.error('Auth Error:', err);
                appendMessage('system', 'Error: Could not authenticate. Chat unavailable.');
                input.disabled = true;
                sendBtn.disabled = true;
                return;
            }

            // 2. Load History
            await loadHistory();

            // 3. Subscribe
            supabase.channel('public:messages')
                .on('postgres_changes', { 
                    event: 'INSERT', 
                    schema: 'public', 
                    table: 'messages', 
                    filter: `conversation_id=eq.${userId}` 
                }, (payload) => {
                    const msg = payload.new;
                    // In case we receive our own message via subscription (duplicate check usually handled by optimistic UI, but here we just append if it's not us or if we want to be sure)
                    // The old logic just called appendMessage.
                    // We will check if it's already there? No, simple append.
                    // But we do optimistic update. So let's avoid duplicating our own if possible.
                    // Actually, the old logic didn't do optimistic updates explicitly in the `subscribeToMessages` function, 
                    // BUT `sendMessage` in old code did NOT append to UI, it just inserted. 
                    // So subscription handled the UI update for own messages too? 
                    // Wait, looking at old code: `sendMessage` did NOT append. `subscribeToMessages` appended everything.
                    // I should probably follow that pattern for simplicity or adapt to optimistic.
                    // I'll stick to: Optimistic append for me, and ignore my own ID in subscription? 
                    // Or just let subscription handle it? Subscription is slower.
                    // I will do: Optimistic append for me. Ignore 'INSERT' if sender_id === me.
                    
                    if (msg.sender_id !== userId) {
                        appendMessage('bot', msg.content);
                    }
                })
                .subscribe();

            // 4. Handle Send
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const text = input.value.trim();
                if (!text) return;

                input.value = '';
                appendMessage('user', text); // Optimistic

                const { error } = await supabase.from('messages').insert({
                    room_id: ROOM_ID,
                    conversation_id: userId,
                    sender_id: userId,
                    content: text,
                    is_bot: false
                });

                if (error) {
                    console.error('Error sending:', error);
                    appendMessage('system', 'Error sending message.');
                }
            });

            async function loadHistory() {
                const { data, error } = await supabase
                    .from('messages')
                    .select('*')
                    .eq('room_id', ROOM_ID)
                    .eq('conversation_id', userId)
                    .order('created_at', { ascending: true });

                if (error) {
                    console.error('Error loading history:', error);
                    return;
                }

                if (data && data.length > 0) {
                    // Clear "Hello" placeholder if we have history? 
                    // My HTML has a hardcoded "Hello". I should probably clear it or keep it as start.
                    // I'll clear the container first.
                    messagesDiv.innerHTML = '';
                    data.forEach(msg => {
                        const role = msg.sender_id === userId ? 'user' : 'bot';
                        appendMessage(role, msg.content);
                    });
                } else {
                    // If no history, show greeting
                    if (messagesDiv.children.length === 0) {
                        appendMessage('bot', 'Hello! I am Alex. How can I help you?');
                    }
                }
            }

            function appendMessage(role, text) {
                const div = document.createElement('div');
                // Map 'system' to 'bot' style but maybe different? Just use 'bot' for now.
                const styleRole = role === 'system' ? 'bot' : role;
                div.className = `message ${styleRole}`;
                div.textContent = text;
                messagesDiv.appendChild(div);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }

        initChat();

    </script>
</body>
</html>