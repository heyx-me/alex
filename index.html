<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D Background</title>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #030305;
            margin: 0;
            padding: 0;
        }
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        const container = document.getElementById('three-container');

        // Scene Setup
        const scene = new THREE.Scene();
        // Add some fog for depth
        scene.fog = new THREE.FogExp2(0x030305, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        container.appendChild(renderer.domElement);

        // Post Processing
        const renderScene = new RenderPass(scene, camera);
        
        // Bloom Parameters: resolution, strength, radius, threshold
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            1.5,  // Strength
            0.4,  // Radius
            0.1   // Threshold
        );
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(new OutputPass());

        // --- NEON TRAILS ---
        function createTrail(color, xOffset, thickness = 0.02) {
            const points = [];
            const segments = 100;
            const heightRange = 80; // Total height of the spiral
            
            for (let i = 0; i < segments; i++) {
                // Create a spiral path
                const t = i / segments; 
                const angle = t * Math.PI * 8 + xOffset; // 4 full rotations
                const y = (t - 0.5) * heightRange;
                const radius = 1.5 + Math.sin(t * Math.PI * 4) * 0.2; // Slight wobble in radius

                points.push(new THREE.Vector3(
                    Math.sin(angle) * radius,
                    y,
                    Math.cos(angle) * radius
                ));
            }
            
            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeom = new THREE.TubeGeometry(curve, 400, thickness, 8, false);
            const tubeMat = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.4 
            });
            const tube = new THREE.Mesh(tubeGeom, tubeMat);
            scene.add(tube);
            return tube;
        }

        const trail1 = createTrail(0x00ffff, 0);                 // Cyan
        const trail2 = createTrail(0xff00ff, Math.PI);           // Magenta
        const trail3 = createTrail(0x00ffff, Math.PI * 0.5, 0.01); // Cyan thin
        const trail4 = createTrail(0xff00ff, Math.PI * 1.5, 0.01); // Magenta thin

        // --- STARFIELD ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 3000;
        const starPos = new Float32Array(starCount * 3);
        
        for(let i = 0; i < starCount * 3; i += 3) {
            starPos[i] = (Math.random() - 0.5) * 100;     // x
            starPos[i+1] = (Math.random() - 0.5) * 100;   // y
            starPos[i+2] = (Math.random() - 0.5) * 60 - 10; // z (mostly in background)
        }
        
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ 
            color: 0x888888, 
            size: 0.15,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- ANIMATION ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Move Trails (Simulate vertical passage)
            // Instead of scrolling, we just rotate them and shift texture/position slightly
            // or just rotate the whole group. Let's rotate individual trails for the helix effect.
            
            const rotationSpeed = 0.2;
            const moveSpeed = 2.0;

            [trail1, trail2, trail3, trail4].forEach((trail, index) => {
                // Rotate around Y axis
                trail.rotation.y += rotationSpeed * delta * (index % 2 === 0 ? 1 : -1);
                
                // Bobbing / "Breathing" effect
                trail.scale.x = 1 + Math.sin(time * 0.5 + index) * 0.05;
                trail.scale.z = 1 + Math.sin(time * 0.5 + index) * 0.05;
            });

            // 2. Move Stars (Parallax / Warp effect)
            const positions = stars.geometry.attributes.position.array;
            const starSpeed = 2.0 * delta;

            for(let i = 0; i < starCount * 3; i += 3) {
                // Move stars upwards (simulating descent) or downwards
                let y = positions[i+1];
                y -= starSpeed;
                
                // Wrap around
                if (y < -50) {
                    y = 50;
                    // Reset X/Z randomly when wrapping to avoid patterns
                    positions[i] = (Math.random() - 0.5) * 100;
                    positions[i+2] = (Math.random() - 0.5) * 60 - 10;
                }
                positions[i+1] = y;

                // Subtle rotation for stars too
                const x = positions[i];
                const z = positions[i+2];
                const angle = 0.05 * delta;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                // Rotate around Y
                positions[i] = x * cos - z * sin;
                positions[i+2] = x * sin + z * cos;
            }
            
            stars.geometry.attributes.position.needsUpdate = true;

            // 3. Camera Movement (Subtle sway)
            camera.position.x = Math.sin(time * 0.2) * 0.5;
            camera.position.y = Math.cos(time * 0.3) * 0.5;
            camera.lookAt(0, 0, 0);

            composer.render();
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.resolution.set(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>